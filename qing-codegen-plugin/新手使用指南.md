# Qing 代码生成器新手使用指南

> 🎯 **目标读者**: 刚接触代码生成器的开发者  
> ⏱️ **预计时间**: 15-30分钟  
> 📋 **前置条件**: 熟悉Java基础语法和Spring Boot

## 📖 什么是代码生成器？

代码生成器是一个自动化工具，它可以根据你定义的实体类，自动生成常用的CRUD（增删改查）代码，包括：
- **VO类** - 用于前端展示的数据对象
- **Service类** - 业务逻辑处理
- **Repository类** - 数据库操作
- **Controller类** - API接口
- **Request/Response类** - 请求和响应对象

**简单来说**：你只需要写一个实体类，剩下的重复代码都由工具自动生成！

## 🚀 5分钟快速上手

### 第一步：添加依赖

在你的项目 `pom.xml` 文件中添加以下依赖：

```xml
<dependency>
    <groupId>cn.chenyunlong</groupId>
    <artifactId>qing-codegen-apt</artifactId>
    <version>0.0.2-SNAPSHOT</version>
    <scope>provided</scope>
</dependency>
```

> ⚠️ **注意**: `scope` 必须设置为 `provided`，这样依赖只在编译时使用。

### 第二步：创建你的第一个实体类

创建一个简单的用户实体类：

```java
package com.example.domain;

import cn.chenyunlong.codegen.annotation.*;
import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;

@Entity
@Table(name = "t_user")
@Data
@EqualsAndHashCode(callSuper = true)
// 🎯 核心注解：告诉代码生成器要生成什么
@GenVo          // 生成VO类
@GenCreator     // 生成创建对象
@GenUpdater     // 生成更新对象
@GenQuery       // 生成查询对象
@GenRepository  // 生成Repository接口
@GenService     // 生成Service接口
@GenServiceImpl // 生成Service实现类
@GenController  // 生成Controller类
public class User extends BaseEntity {
    
    @Column(name = "username", nullable = false, length = 50)
    private String username;
    
    @Column(name = "email", nullable = false, length = 100)
    private String email;
    
    @Column(name = "age")
    private Integer age;
}
```

### 第三步：编译项目

在项目根目录执行编译命令：

```bash
mvn clean compile
```

### 第四步：查看生成的代码

编译完成后，你会发现项目中自动生成了以下文件：

```
src/main/java/com/example/
├── domain/
│   └── User.java                    # 你写的实体类
├── vo/
│   └── UserVO.java                  # 自动生成的VO类
├── creator/
│   └── UserCreator.java             # 自动生成的创建对象
├── updater/
│   └── UserUpdater.java             # 自动生成的更新对象
├── query/
│   └── UserQuery.java               # 自动生成的查询对象
├── repository/
│   └── UserRepository.java          # 自动生成的Repository
├── service/
│   ├── IUserService.java            # 自动生成的Service接口
│   └── UserServiceImpl.java         # 自动生成的Service实现
└── controller/
    └── UserController.java          # 自动生成的Controller
```

🎉 **恭喜！** 你已经成功使用代码生成器生成了完整的CRUD代码！

## 📚 注解详解

### 核心注解（必须掌握）

| 注解 | 作用 | 生成内容 | 是否必需 |
|------|------|----------|----------|
| `@GenVo` | 生成视图对象 | `{Entity}VO.java` | 推荐 |
| `@GenCreator` | 生成创建对象 | `{Entity}Creator.java` | 推荐 |
| `@GenUpdater` | 生成更新对象 | `{Entity}Updater.java` | 推荐 |
| `@GenQuery` | 生成查询对象 | `{Entity}Query.java` | 推荐 |
| `@GenRepository` | 生成数据访问层 | `{Entity}Repository.java` | 必需 |
| `@GenService` | 生成服务接口 | `I{Entity}Service.java` | 必需 |
| `@GenServiceImpl` | 生成服务实现 | `{Entity}ServiceImpl.java` | 必需 |
| `@GenController` | 生成控制器 | `{Entity}Controller.java` | 推荐 |

### 扩展注解（可选）

| 注解 | 作用 | 生成内容 | 使用场景 |
|------|------|----------|----------|
| `@GenCreateRequest` | 生成创建请求 | `{Entity}CreateRequest.java` | API开发 |
| `@GenUpdateRequest` | 生成更新请求 | `{Entity}UpdateRequest.java` | API开发 |
| `@GenQueryRequest` | 生成查询请求 | `{Entity}QueryRequest.java` | API开发 |
| `@GenResponse` | 生成响应对象 | `{Entity}Response.java` | API开发 |
| `@GenFeign` | 生成Feign客户端 | `{Entity}FeignClient.java` | 微服务 |
| `@GenMapper` | 生成对象映射器 | `{Entity}Mapper.java` | 对象转换 |

## 🛠️ 实战示例

### 示例1：简单的商品管理

```java
@Entity
@Table(name = "t_product")
@Data
@EqualsAndHashCode(callSuper = true)
@GenVo
@GenCreator
@GenUpdater
@GenQuery
@GenRepository
@GenService
@GenServiceImpl
@GenController
public class Product extends BaseEntity {
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(name = "stock", nullable = false)
    private Integer stock;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private ProductStatus status;
    
    public enum ProductStatus {
        ACTIVE("上架"),
        INACTIVE("下架"),
        OUT_OF_STOCK("缺货");
        
        private final String description;
        
        ProductStatus(String description) {
            this.description = description;
        }
        
        public String getDescription() {
            return description;
        }
    }
}
```

### 示例2：带验证的用户管理

```java
@Entity
@Table(name = "t_user")
@Data
@EqualsAndHashCode(callSuper = true)
@GenVo
@GenCreator
@GenUpdater
@GenQuery
@GenRepository
@GenService
@GenServiceImpl
@GenController
@GenCreateRequest  // 额外生成API请求对象
@GenUpdateRequest
@GenResponse
public class User extends BaseEntity {
    
    @Column(name = "username", nullable = false, unique = true, length = 50)
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3-50个字符之间")
    private String username;
    
    @Column(name = "email", nullable = false, unique = true, length = 100)
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @Column(name = "phone", length = 20)
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Column(name = "age")
    @Min(value = 0, message = "年龄不能小于0")
    @Max(value = 150, message = "年龄不能大于150")
    private Integer age;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private UserStatus status;
    
    public enum UserStatus {
        ACTIVE("正常"),
        INACTIVE("未激活"),
        LOCKED("已锁定"),
        DELETED("已删除");
        
        private final String description;
        
        UserStatus(String description) {
            this.description = description;
        }
        
        public String getDescription() {
            return description;
        }
    }
}
```

## ❓ 常见问题解答

### Q1: 编译后没有生成代码怎么办？

**可能原因和解决方案：**

1. **检查依赖配置**
   ```xml
   <!-- 确保scope是provided -->
   <dependency>
       <groupId>cn.chenyunlong</groupId>
       <artifactId>qing-codegen-apt</artifactId>
       <version>0.0.2-SNAPSHOT</version>
       <scope>provided</scope>
   </dependency>
   ```

2. **检查注解是否正确添加**
   ```java
   // 确保导入了正确的注解包
   import cn.chenyunlong.codegen.annotation.*;
   ```

3. **清理并重新编译**
   ```bash
   mvn clean compile
   ```

4. **检查实体类是否继承BaseEntity**
   ```java
   public class User extends BaseEntity {
       // ...
   }
   ```

### Q2: 生成的代码编译错误怎么办？

**常见编译错误和解决方案：**

1. **找不到BaseEntity类**
   - 确保项目中有BaseEntity基类
   - 或者使用项目中已有的基类

2. **包名不正确**
   - 检查实体类的包名
   - 生成的代码会在相同包下的子包中

3. **缺少必要的依赖**
   ```xml
   <!-- 添加JPA依赖 -->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-jpa</artifactId>
   </dependency>
   
   <!-- 添加Web依赖 -->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   ```

### Q3: 如何自定义生成的代码？

**注解参数配置：**

```java
// 自定义包名
@GenVo(pkgName = "dto")
@GenController(pkgName = "api.v1")

// 自定义源码路径
@GenService(sourcePath = "src/main/java")

// 是否覆盖已存在的文件
@GenServiceImpl(overwrite = true)
public class User extends BaseEntity {
    // ...
}
```

### Q4: 生成的代码可以手动修改吗？

**不建议直接修改生成的代码**，因为重新编译时会被覆盖。

**推荐的扩展方式：**

1. **继承方式扩展**
   ```java
   @Service
   public class CustomUserService extends UserServiceImpl {
       
       // 添加自定义方法
       public List<User> findActiveUsers() {
           return repository.findByStatus(UserStatus.ACTIVE);
       }
   }
   ```

2. **组合方式扩展**
   ```java
   @Service
   public class UserBusinessService {
       
       @Autowired
       private IUserService userService;
       
       // 添加复杂业务逻辑
       public void processUserRegistration(User user) {
           // 自定义业务逻辑
           userService.save(user);
       }
   }
   ```

### Q5: 如何处理复杂的业务逻辑？

代码生成器主要处理基础的CRUD操作，复杂业务逻辑建议：

1. **在Service层添加自定义方法**
2. **创建专门的业务服务类**
3. **使用设计模式（策略模式、工厂模式等）**

## 🎯 最佳实践

### 1. 实体类设计原则

```java
// ✅ 好的实体类设计
@Entity
@Table(name = "t_user")  // 明确指定表名
@Data
@EqualsAndHashCode(callSuper = true)
@GenVo
@GenCreator
@GenUpdater
@GenQuery
@GenRepository
@GenService
@GenServiceImpl
@GenController
public class User extends BaseEntity {
    
    // 使用合适的数据类型
    @Column(name = "username", nullable = false, length = 50)
    private String username;
    
    // 添加验证注解
    @Email(message = "邮箱格式不正确")
    @Column(name = "email", nullable = false, length = 100)
    private String email;
    
    // 使用枚举类型
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private UserStatus status;
    
    // 枚举定义在实体类内部
    public enum UserStatus {
        ACTIVE("正常"),
        INACTIVE("未激活");
        
        private final String description;
        
        UserStatus(String description) {
            this.description = description;
        }
        
        public String getDescription() {
            return description;
        }
    }
}
```

### 2. 注解使用建议

```java
// 基础功能：适用于大部分场景
@GenVo
@GenCreator
@GenUpdater
@GenQuery
@GenRepository
@GenService
@GenServiceImpl
@GenController

// API开发：需要对外提供接口时添加
@GenCreateRequest
@GenUpdateRequest
@GenQueryRequest
@GenResponse

// 微服务：需要服务间调用时添加
@GenFeign

// 对象转换：需要复杂对象映射时添加
@GenMapper
```

### 3. 项目结构建议

```
src/main/java/com/example/
├── domain/              # 实体类
│   ├── User.java
│   └── Product.java
├── vo/                  # 视图对象
├── creator/             # 创建对象
├── updater/             # 更新对象
├── query/               # 查询对象
├── request/             # 请求对象
├── response/            # 响应对象
├── repository/          # 数据访问层
├── service/             # 服务层
├── controller/          # 控制器层
└── mapper/              # 对象映射器
```

### 4. 性能优化建议

1. **启用缓存**（默认已启用）
   ```properties
   # application.properties
   qing.codegen.cache.enabled=true
   ```

2. **增量编译**
   ```bash
   # 只编译变更的文件
   mvn compile
   ```

3. **并行编译**
   ```bash
   # 使用多线程编译
   mvn compile -T 4
   ```

## 🔧 高级配置

### 配置文件示例

在 `application.properties` 中添加配置：

```properties
# 代码生成器配置
qing.codegen.cache.enabled=true
qing.codegen.cache.directory=target/codegen-cache
qing.codegen.force.regenerate=false
qing.codegen.output.directory=src/main/java
qing.codegen.package.prefix=com.example
qing.codegen.generate.comments=true
```

### Maven配置优化

```xml
<build>
    <plugins>
        <!-- 编译插件配置 -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.8.1</version>
            <configuration>
                <source>11</source>
                <target>11</target>
                <encoding>UTF-8</encoding>
                <!-- 启用注解处理器 -->
                <annotationProcessorPaths>
                    <path>
                        <groupId>cn.chenyunlong</groupId>
                        <artifactId>qing-codegen-apt</artifactId>
                        <version>0.0.2-SNAPSHOT</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>
```

## 🎉 总结

通过本指南，你应该已经掌握了：

✅ **基础使用**：如何添加依赖、创建实体类、生成代码  
✅ **注解理解**：各种注解的作用和使用场景  
✅ **实战技能**：通过示例学会实际应用  
✅ **问题解决**：常见问题的排查和解决方法  
✅ **最佳实践**：如何写出高质量的代码  

## 📞 获取帮助

如果你在使用过程中遇到问题：

1. **查看完整文档**：[README.md](readme.md)
2. **查看示例代码**：[EXAMPLES.md](EXAMPLES.md)
3. **提交Issue**：[GitHub Issues](https://github.com/chenyunlong/qing/issues)
4. **加入讨论**：[GitHub Discussions](https://github.com/chenyunlong/qing/discussions)

---

🚀 **开始你的代码生成之旅吧！** 记住，熟能生巧，多练习几次就能熟练掌握了。